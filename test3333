import sailpoint.object.Identity;
import sailpoint.object.Application;
import sailpoint.object.Role;
import sailpoint.object.Policy;
import sailpoint.object.Rule;
import sailpoint.api.SailPointContext;
import sailpoint.tools.GeneralException;
import java.util.Date;
import java.util.Calendar;
import java.util.List;
import java.util.ArrayList;
import sailpoint.object.QueryOptions;
import sailpoint.object.Filter; // On peut encore l'utiliser pour des filtres non-date

// Les variables 'context' et 'log' sont automatiquement disponibles.

List<String> changedObjectNames = new ArrayList<>();

// 1. Définir les dates de début et de fin pour la comparaison
Calendar cal = Calendar.getInstance();

// Définir la fin de la journée d'aujourd'hui (23:59:59.999)
cal.set(Calendar.HOUR_OF_DAY, 23);
cal.set(Calendar.MINUTE, 59);
cal.set(Calendar.SECOND, 59);
cal.set(Calendar.MILLISECOND, 999);
Date endDateInclusive = cal.getTime(); // Date de fin incluse dans la plage

// Définir le début de la journée d'hier (00:00:00.000)
cal.add(Calendar.DAY_OF_MONTH, -1); // Recule d'un jour par rapport à endDateInclusive
cal.set(Calendar.HOUR_OF_DAY, 0);
cal.set(Calendar.MINUTE, 0);
cal.set(Calendar.SECOND, 0);
cal.set(Calendar.MILLISECOND, 0);
Date startDateInclusive = cal.getTime(); // Date de début incluse dans la plage

log.debug("Recherche des objets modifiés entre : " + startDateInclusive + " et " + endDateInclusive);

// 2. Récupérer tous les objets d'un type donné et les filtrer en mémoire

// a) Identités (Identity)
// Pour les identités, une recherche sans filtre peut être très coûteuse.
// On pourrait potentiellement ajouter un filtre simple qui marche toujours,
// par exemple pour récupérer les identités actives ou non nulles.
// Pour l'exemple, nous allons récupérer toutes les identités et filtrer.
List<Identity> allIdentities = context.getObjects(Identity.class);
for (Identity id : allIdentities) {
    if (id.getModified() != null && id.getModified().after(startDateInclusive) && id.getModified().before(endDateInclusive)) {
        changedObjectNames.add("Identity: " + id.getName() + " (Last Modified: " + id.getModified() + ")");
    }
    // Inclure les objets créés entre les dates si vous le souhaitez aussi
    // else if (id.getCreated() != null && id.getCreated().after(startDateInclusive) && id.getCreated().before(endDateInclusive)) {
    //     changedObjectNames.add("New Identity: " + id.getName() + " (Created: " + id.getCreated() + ")");
    // }
}


// b) Applications (Application)
List<Application> allApplications = context.getObjects(Application.class);
for (Application app : allApplications) {
    if (app.getModified() != null && app.getModified().after(startDateInclusive) && app.getModified().before(endDateInclusive)) {
        changedObjectNames.add("Application: " + app.getName() + " (Last Modified: " + app.getModified() + ")");
    }
}

// c) Rôles (Role)
List<Role> allRoles = context.getObjects(Role.class);
for (Role role : allRoles) {
    if (role.getModified() != null && role.getModified().after(startDateInclusive) && role.getModified().before(endDateInclusive)) {
        changedObjectNames.add("Role: " + role.getName() + " (Last Modified: " + role.getModified() + ")");
    }
}

// d) Politiques (Policy)
List<Policy> allPolicies = context.getObjects(Policy.class);
for (Policy policy : allPolicies) {
    if (policy.getModified() != null && policy.getModified().after(startDateInclusive) && policy.getModified().before(endDateInclusive)) {
        changedObjectNames.add("Policy: " + policy.getName() + " (Last Modified: " + policy.getModified() + ")");
    }
}

// e) Règles (Rule)
List<Rule> allRules = context.getObjects(Rule.class);
for (Rule rule : allRules) {
    if (rule.getModified() != null && rule.getModified().after(startDateInclusive) && rule.getModified().before(endDateInclusive)) {
        changedObjectNames.add("Rule: " + rule.getName() + " (Last Modified: " + rule.getModified() + ")");
    }
}

log.debug("Nombre d'objets modifiés trouvés: " + changedObjectNames.size());

return changedObjectNames;
