import sailpoint.object.Identity;
import sailpoint.object.Application;
import sailpoint.object.Role;
import sailpoint.object.Policy;
import sailpoint.object.Rule;
import sailpoint.api.SailPointContext;
import sailpoint.tools.GeneralException;
import java.util.Date;
import java.util.Calendar;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
import java.text.SimpleDateFormat; // Import for date formatting

// The 'context' and 'log' variables are automatically available.

List changedObjectNames = new ArrayList();

// 1. Define the date range
Calendar cal = Calendar.getInstance();

// Define the "exclusive" end date: beginning of tomorrow (00:00:00.000)
cal.add(Calendar.DAY_OF_MONTH, 1); // Advance one day
cal.set(Calendar.HOUR_OF_DAY, 0);
cal.set(Calendar.MINUTE, 0);
cal.set(Calendar.SECOND, 0);
cal.set(Calendar.MILLISECOND, 0);
Date tomorrowStart = cal.getTime();

// Define the "inclusive" start date: beginning of yesterday (00:00:00.000)
cal = Calendar.getInstance(); // Reset calendar to current time
cal.add(Calendar.DAY_OF_MONTH, -1); // Go back one day
cal.set(Calendar.HOUR_OF_DAY, 0);
cal.set(Calendar.MINUTE, 0);
cal.set(Calendar.SECOND, 0);
cal.set(Calendar.MILLISECOND, 0);
Date yesterdayStart = cal.getTime();

// For debugging/logging purposes
log.debug("Target Date Range (HQL): From " + yesterdayStart + " (inclusive) to " + tomorrowStart + " (exclusive)");

// 2. Format dates into strings for HQL comparison
// Use a SimpleDateFormat to convert dates to a database-friendly string format.
// This format (ISO 8601) is generally well-understood by most databases.
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
String startDateFormatted = sdf.format(yesterdayStart);
String endDateFormatted = sdf.format(tomorrowStart); // This will be the exclusive end

log.debug("Formatted Date Strings for HQL: startDate = '" + startDateFormatted + "', endDate = '" + endDateFormatted + "'");


// 3. Query objects using HQL with formatted date strings
// Instead of passing Date objects as parameters, embed the formatted strings directly.
// Note: If your database expects a specific function (e.g., TO_DATE in Oracle) around the string,
// you might need to add that. For most cases, direct string comparison works if format is correct.

// No need for a separate Map for parameters if embedding strings directly
// Map hqlParams = new HashMap(); // Not used in this approach for dates
// hqlParams.put("startDate", yesterdayStart);
// hqlParams.put("endDate", tomorrowStart);

// a) Identities (Identity)
// Using single quotes around the date strings in HQL to treat them as literals
String hqlIdentity = "FROM Identity WHERE modified >= '" + startDateFormatted + "' AND modified < '" + endDateFormatted + "'";
log.debug("Executing HQL for Identity: " + hqlIdentity);
Iterator itIdentity = context.search(hqlIdentity, null); // Pass null for parameters if embedding strings
while (itIdentity.hasNext()) {
    Identity id = (Identity) itIdentity.next();
    changedObjectNames.add("Identity: " + id.getName() + " (Last Modified: " + id.getModified() + ")");
}

// b) Applications (Application)
String hqlApplication = "FROM Application WHERE modified >= '" + startDateFormatted + "' AND modified < '" + endDateFormatted + "'";
log.debug("Executing HQL for Application: " + hqlApplication);
Iterator itApplication = context.search(hqlApplication, null);
while (itApplication.hasNext()) {
    Application app = (Application) itApplication.next();
    changedObjectNames.add("Application: " + app.getName() + " (Last Modified: " + app.getModified() + ")");
}

// c) Roles (Role)
String hqlRole = "FROM Role WHERE modified >= '" + startDateFormatted + "' AND modified < '" + endDateFormatted + "'";
log.debug("Executing HQL for Role: " + hqlRole);
Iterator itRole = context.search(hqlRole, null);
while (itRole.hasNext()) {
    Role role = (Role) itRole.next();
    changedObjectNames.add("Role: " + role.getName() + " (Last Modified: " + role.getModified() + ")");
}

// d) Policies (Policy)
String hqlPolicy = "FROM Policy WHERE modified >= '" + startDateFormatted + "' AND modified < '" + endDateFormatted + "'";
log.debug("Executing HQL for Policy: " + hqlPolicy);
Iterator itPolicy = context.search(hqlPolicy, null);
while (itPolicy.hasNext()) {
    Policy policy = (Policy) itPolicy.next();
    changedObjectNames.add("Policy: " + policy.getName() + " (Last Modified: " + policy.getModified() + ")");
}

// e) Rules (Rule)
String hqlRule = "FROM Rule WHERE modified >= '" + startDateFormatted + "' AND modified < '" + endDateFormatted + "'";
log.debug("Executing HQL for Rule: " + hqlRule);
Iterator itRule = context.search(hqlRule, null);
while (itRule.hasNext()) {
    Rule rule = (Rule) itRule.next();
    changedObjectNames.add("Rule: " + rule.getName() + " (Last Modified: " + rule.getModified() + ")");
}

log.debug("Total number of modified objects found: " + changedObjectNames.size());

return changedObjectNames;
