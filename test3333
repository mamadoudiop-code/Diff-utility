import sailpoint.object.Identity;
import sailpoint.object.Application;
import sailpoint.object.Role;
import sailpoint.object.Policy;
import sailpoint.object.Rule;
import sailpoint.api.SailPointContext;
import sailpoint.tools.GeneralException;
import java.util.Date;
import java.util.Calendar;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap; // Assurez-vous que HashMap est bien importé

// Les variables 'context' et 'log' sont automatiquement disponibles.

List<String> changedObjectNames = new ArrayList<>();

// 1. Définir la plage de dates
// Nous allons chercher les modifications depuis le début d'hier jusqu'à la fin d'aujourd'hui.

Calendar cal = Calendar.getInstance();

// Définir la date de fin "exclusive" : le début de demain (00:00:00.000)
// Cela signifie que nous inclurons toutes les modifications jusqu'à la dernière milliseconde d'aujourd'hui.
cal.add(Calendar.DAY_OF_MONTH, 1); // Avance d'un jour
cal.set(Calendar.HOUR_OF_DAY, 0);
cal.set(Calendar.MINUTE, 0);
cal.set(Calendar.SECOND, 0);
cal.set(Calendar.MILLISECOND, 0);
Date tomorrowStart = cal.getTime();

// Définir la date de début "inclusive" : le début d'hier (00:00:00.000)
cal = Calendar.getInstance(); // Réinitialiser le calendrier à l'heure actuelle
cal.add(Calendar.DAY_OF_MONTH, -1); // Recule d'un jour
cal.set(Calendar.HOUR_OF_DAY, 0);
cal.set(Calendar.MINUTE, 0);
cal.set(Calendar.SECOND, 0);
cal.set(Calendar.MILLISECOND, 0);
Date yesterdayStart = cal.getTime();


log.debug("Recherche des objets modifiés (HQL) entre : " + yesterdayStart + " (inclus) et " + tomorrowStart + " (exclus)");

// 2. Interroger les objets en utilisant des requêtes HQL

// Déclaration de la Map sans génériques
Map hqlParams = new HashMap();
hqlParams.put("startDate", yesterdayStart);
hqlParams.put("endDate", tomorrowStart); // Renommé pour clarté en HQL, mais reste "exclusif"

// a) Identités (Identity)
String hqlIdentity = "FROM Identity WHERE modified >= :startDate AND modified < :endDate";
Iterator itIdentity = context.search(hqlIdentity, hqlParams); // L'Iterator n'a pas non plus besoin de générique
while (itIdentity.hasNext()) {
    Identity id = (Identity) itIdentity.next(); // Cast explicite est nécessaire pour le type d'objet
    changedObjectNames.add("Identity: " + id.getName() + " (Last Modified: " + id.getModified() + ")");
}

// b) Applications (Application)
String hqlApplication = "FROM Application WHERE modified >= :startDate AND modified < :endDate";
Iterator itApplication = context.search(hqlApplication, hqlParams);
while (itApplication.hasNext()) {
    Application app = (Application) itApplication.next();
    changedObjectNames.add("Application: " + app.getName() + " (Last Modified: " + app.getModified() + ")");
}

// c) Rôles (Role)
String hqlRole = "FROM Role WHERE modified >= :startDate AND modified < :endDate";
Iterator itRole = context.search(hqlRole, hqlParams);
while (itRole.hasNext()) {
    Role role = (Role) itRole.next();
    changedObjectNames.add("Role: " + role.getName() + " (Last Modified: " + role.getModified() + ")");
}

// d) Politiques (Policy)
String hqlPolicy = "FROM Policy WHERE modified >= :startDate AND modified < :endDate";
Iterator itPolicy = context.search(hqlPolicy, hqlParams);
while (itPolicy.hasNext()) {
    Policy policy = (Policy) itPolicy.next();
    changedObjectNames.add("Policy: " + policy.getName() + " (Last Modified: " + policy.getModified() + ")");
}

// e) Règles (Rule)
String hqlRule = "FROM Rule WHERE modified >= :startDate AND modified < :endDate";
Iterator itRule = context.search(hqlRule, hqlParams);
while (itRule.hasNext()) {
    Rule rule = (Rule) itRule.next();
    changedObjectNames.add("Rule: " + rule.getName() + " (Last Modified: " + rule.getModified() + ")");
}

log.debug("Nombre d'objets modifiés trouvés: " + changedObjectNames.size());

return changedObjectNames;
